#include <iostream>


template <typename T>
void my_swap(T num1, T num2) {

	T tmp = num1;
	num1 = num2;
	num2 = tmp;
	}

template <typename T>
void p_swap(T *num1, T *num2) {
	T tmp = *num1;
	*num1 = *num2;
	*num2 = tmp;
}

template <typename T>
void ref_swap(T &num1, T&num2) {
	T tmp = num1;
	num1 = num2;
	num2 = tmp;
}


int MX[10][2];
int& func(int index) {
	return MX[index][1];



}



int main() {
	setlocale(LC_ALL, "Russian");
	int n, m;
	// p + переменная 

	std::cout << "Ввод в массив. \n";
	for (int i = 0; i < 10; i++) {
		std::cout << "Введите " << i + 1 << "-й элемент -> ";
			std::cin >> MX[i][0];
		func(i) = MX[i][0];
		
	}
	std::cout << "Итоговый массив:\n";
	for (int i{}; i <  10; i++)
		std::cout << MX[i][0] << "\t" << func(i) << "\n";

	
	//ссылки
	// В отличие от указателей, которые могут быть объявлены не иниуиализированными или установленными в нуль (0; NULL,.\ nullptr).
	// Ссылки всегда ссылаются на объект Для ссылок ОБЯЗАТЕЛЬНА инцилизация при создании и не существует аналога нетрального указателя
	// Не существует операторов непосредственно производящих действия над ссылками ! Это происходит потому что ссылка - второе имя некоторого объекта . И все
	// операции над этим объектом
	// Стандарт С++ не определяет как компилячтор должен реализовать механизм ссылок Некоторые заменяют обращение ссылке
	//обращением к рееальной переменной. Некоторые заменяют ссылку на указатель, через который обращение к переменной сы же же будем считать что ссылка это всевдоним для переменной
		/*
	n = 10; m = 20;
	int &refn = n; // ссылка, ассоциирующаяся с переменной n
	std::cout << "refn=  "<< refn << std::endl;
	refn = m;
	std::cout << "refn = " << refn << std::endl;
	std::cout << " n = " << n  << std::endl;
	*/
	
	//ссылки параметры функции
	/*
	n = 10; m = 15;
	std::cout << n << ' ' << m << std::endl;
	//p_swap(&n, &m); // работает но не удобная
	ref_swap(n, m);
	std::cout << n << ' ' << m << std::endl;
	*/
	
	
	
	
	return 0;
	
	}








